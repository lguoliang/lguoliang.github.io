(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{391:function(t,e,a){"use strict";a.r(e);var v=a(26),s=Object(v.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"question"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#question"}},[t._v("#")]),t._v(" question")]),t._v(" "),a("h2",{attrs:{id:"cookie-sessionstorage-localstorage-区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cookie-sessionstorage-localstorage-区别"}},[t._v("#")]),t._v(" cookie sessionStorage localStorage 区别?")]),t._v(" "),a("ol",[a("li",[t._v("都是浏览器存储")]),t._v(" "),a("li",[t._v("都存储在浏览器本地")])]),t._v(" "),a("p",[t._v("区别：")]),t._v(" "),a("ol",[a("li",[t._v("cookie由服务器写入， sessionStorage以及localStorage都是由前端写入")]),t._v(" "),a("li",[t._v("cookie的生命周期由服务器端写入时就设置好的，localStorage是写入就一直存在，除非手动清除，sessionStorage是由页面关闭时自动清除")]),t._v(" "),a("li",[t._v("cookie存储空间大小约4kb， sessionStorage及localStorage空间比较大，大约5M")]),t._v(" "),a("li",[t._v("3者的数据共享都遵循同源原则，sessionStorage还限制必须是同一个页面")]),t._v(" "),a("li",[t._v("前端给后端发送请求时，自动携带cookie, session 及 local都不携带")]),t._v(" "),a("li",[t._v("cookie一般存储登录验证信息或者token，localStorage常用于存储不易变动的数据，减轻服务器压力，sessionStorage可以用来监测用户是否是刷新进入页面，如音乐播放器恢复进度条功能")])]),t._v(" "),a("h2",{attrs:{id:"js数据类型有哪些-区别是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js数据类型有哪些-区别是什么"}},[t._v("#")]),t._v(" JS数据类型有哪些,区别是什么？")]),t._v(" "),a("p",[t._v("原始数据类型：number、string、boolean、undefined、null、symbol、bigint")]),t._v(" "),a("p",[t._v("引用数据类型：object（包括Array，Function、Object类等）")]),t._v(" "),a("p",[t._v("区别：前七中原生数据类型的存放在栈中，引用数据类型存放在堆中，它的地址在栈中，一般我们访问就是它的地址")]),t._v(" "),a("h2",{attrs:{id:"对闭包的理解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对闭包的理解"}},[t._v("#")]),t._v(" 对闭包的理解？")]),t._v(" "),a("p",[t._v("闭包形成的原理：作用域链，当前作用域可以访问上级作用域中的变量")]),t._v(" "),a("p",[t._v("闭包解决的问题：能够让函数作用域中的变量在函数执行结束之后不被销毁，同时也能在函数外部可以访问函数内部的局部变量。")]),t._v(" "),a("p",[t._v("闭包带来的问题：由于垃圾回收器不会将闭包中变量销毁，于是就造成了内存泄露，内存泄露积累多了就容易导致内存溢出。")]),t._v(" "),a("p",[t._v("闭包的应用，能够模仿块级作用域，能够实现柯里化，防止污染全局变量, 在构造函数中定义特权方法、Vue中数据响应式Observer中使用闭包等。")]),t._v(" "),a("h2",{attrs:{id:"promise是什么与使用方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#promise是什么与使用方法"}},[t._v("#")]),t._v(" promise是什么与使用方法？")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("概念：异步编程的一种解决方案，解决了地狱回调的问题")])]),t._v(" "),a("li",[a("p",[t._v("使用方法：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Promise")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("resolve"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("reject")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("resolve")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("reject")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("p",[t._v("里面有多个resovle或者reject只执行第一个。如果第一个是resolve的话后面可以接.then查看成功消息。如果第一个是reject的话，.catch查看错误消息。")]),t._v(" "),a("p",[t._v("Promise是宏任务（同步执行），只有Promise的回调是异步微任务。")])])]),t._v(" "),a("h2",{attrs:{id:"跨域是什么-如何解决跨域问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#跨域是什么-如何解决跨域问题"}},[t._v("#")]),t._v(" 跨域是什么？如何解决跨域问题？")]),t._v(" "),a("ol",[a("li",[t._v("跨域：本质就是违反了同源策略，当接口请求的地址和当前页面的协议名、域名、端口号的任意一项不同就形成跨域，这个其实是浏览器的一种自我保护现象。")]),t._v(" "),a("li",[t._v("解决方案： jsonp、前端proxy、后端cors、web socket、nginx")])]),t._v(" "),a("h2",{attrs:{id:"什么是bfc"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是bfc"}},[t._v("#")]),t._v(" 什么是BFC")]),t._v(" "),a("ol",[a("li",[t._v("定义：块级格式化上下文，独立的渲染区域，不会影响边界外的元素")]),t._v(" "),a("li",[t._v("形成条件：\n"),a("ol",[a("li",[t._v("float")]),t._v(" "),a("li",[t._v("position")]),t._v(" "),a("li",[t._v("overflow")]),t._v(" "),a("li",[t._v("display")])])]),t._v(" "),a("li",[t._v("3.布局规则：\n"),a("ol",[a("li",[t._v("区域内box从上到下排列")]),t._v(" "),a("li",[t._v("box垂直方向的距离由margin决定")]),t._v(" "),a("li",[t._v("同一个bfc内box margin会重叠")]),t._v(" "),a("li",[t._v("bfc不会与flaot重叠")]),t._v(" "),a("li",[t._v("bfc计算高度 也会计算float元素")])])])]),t._v(" "),a("h2",{attrs:{id:"vuex是什么-每个属性是干嘛的-如何使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vuex是什么-每个属性是干嘛的-如何使用"}},[t._v("#")]),t._v(" Vuex是什么，每个属性是干嘛的，如何使用 ？")]),t._v(" "),a("ol",[a("li",[t._v("概念：Vuex是全局状态管理仓库，相当于window对象挂载了一个全局变量。")]),t._v(" "),a("li",[t._v("属性：state（数据源）、actions（处理异步事件）、mutations（处理同步事件）、getters(过滤数据)和modules（模块）")])]),t._v(" "),a("h2",{attrs:{id:"javascript有几种方法判断变量的类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#javascript有几种方法判断变量的类型"}},[t._v("#")]),t._v(" JavaScript有几种方法判断变量的类型？")]),t._v(" "),a("ol",[a("li",[t._v("typeof（根据二进制判断）,不能判断数据类型：null和object")]),t._v(" "),a("li",[t._v("intanceof(根据原型链判断),原生数据类型不能判断")]),t._v(" "),a("li",[t._v("constructor.name(根据构造器判断)，不能判断null数据类型")]),t._v(" "),a("li",[t._v("Object.prototype.toString.call()（用Object的toString方法判断）所有类型数据都能判断,记住判断结果打印为：'[object Xxx]'")])]),t._v(" "),a("h2",{attrs:{id:"样式优先级的规则是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#样式优先级的规则是什么"}},[t._v("#")]),t._v(" 样式优先级的规则是什么？")]),t._v(" "),a("p",[t._v("!important > 内联样式（style） > ID选择器（id） > 类选择器(class) > 标签选择器")]),t._v(" "),a("h2",{attrs:{id:"js实现异步的方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js实现异步的方法"}},[t._v("#")]),t._v(" JS实现异步的方法？")]),t._v(" "),a("p",[t._v("回调函数，promise，async/await, generator")]),t._v(" "),a("h2",{attrs:{id:"vue2-0-双向绑定的原理与缺陷"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue2-0-双向绑定的原理与缺陷"}},[t._v("#")]),t._v(" Vue2.0 双向绑定的原理与缺陷？")]),t._v(" "),a("p",[t._v("原理：vue的双向绑定是采用数据劫持结合发布者订阅者模式的方式来实现响应式，通过object.defineProperty来劫持数据的getter，setter,在数据变化时发送消息给订阅者，订阅者收到消息后进行相应的处理。")]),t._v(" "),a("p",[t._v("缺陷：只能够监听初始化实例中的data数据，动态添加值不能响应，要使用对应的Vue.set()。")]),t._v(" "),a("h2",{attrs:{id:"数组去重都有哪些方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数组去重都有哪些方法"}},[t._v("#")]),t._v(" 数组去重都有哪些方法？")]),t._v(" "),a("ol",[a("li",[t._v("双循环")]),t._v(" "),a("li",[t._v("filter")]),t._v(" "),a("li",[t._v("es6 array.form(new set())")]),t._v(" "),a("li",[t._v("includes()")])]),t._v(" "),a("h2",{attrs:{id:"null-和-undefined-的区别-如何让一个属性变为null"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#null-和-undefined-的区别-如何让一个属性变为null"}},[t._v("#")]),t._v(" null 和 undefined 的区别，如何让一个属性变为null")]),t._v(" "),a("p",[t._v("null 是定义 并赋值null undefined是定义未赋值")]),t._v(" "),a("h2",{attrs:{id:"说一下浮动"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#说一下浮动"}},[t._v("#")]),t._v(" 说一下浮动？")]),t._v(" "),a("ol",[a("li",[t._v("脱离文档流，盒子塌陷，影响其他元素排版")])]),t._v(" "),a("p",[t._v("解决方案：")]),t._v(" "),a("ol",[a("li",[t._v("父元素设置overflow：hidden")]),t._v(" "),a("li",[t._v("父元素设置高度")]),t._v(" "),a("li",[t._v("增加一个空的div，设置clear：both")]),t._v(" "),a("li",[t._v("添加一个after伪类")])]),t._v(" "),a("h2",{attrs:{id:"es6中箭头函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#es6中箭头函数"}},[t._v("#")]),t._v(" es6中箭头函数？")]),t._v(" "),a("p",[t._v("写法简洁，没有this, 从外部获取，不能new，没有arguments，没有原型和super")]),t._v(" "),a("h2",{attrs:{id:"call-apply-bind的作用和区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#call-apply-bind的作用和区别"}},[t._v("#")]),t._v(" call apply bind的作用和区别？")]),t._v(" "),a("p",[t._v("首先，call apply bind三个方法都可以用来改变函数的this指向，具体区别如下：")]),t._v(" "),a("ol",[a("li",[t._v("fn.call (newThis,params) call函数的第一个参数是this的新指向，后面依次传入函数fn要用到的参数。会立即执行fn函数。")]),t._v(" "),a("li",[t._v("fn.apply (newThis,paramsArr) apply函数的第一个参数是this的新指向,第二个参数是fn要用到的参数数组，会立即执行fn函数。")]),t._v(" "),a("li",[t._v("fn.bind (newThis,params) bind函数的第一个参数是this的新指向，后面的参数可以直接传递，也可以按数组的形式传入。  不会立即执行fn函数，且只能改变一次fn函数的指向，后续再用bind更改无效。返回的是已经更改this指向的新fn")])]),t._v(" "),a("h2",{attrs:{id:"说一说html语义化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#说一说html语义化"}},[t._v("#")]),t._v(" 说一说HTML语义化？")]),t._v(" "),a("p",[t._v("语义化的好处： 1. 代码可读高 2. 有利于SEO 3. 利于页面内容结构化 常见的语义化标签：header、footer、aside、main、h1-h6、input、textarea、video、aduio")]),t._v(" "),a("h2",{attrs:{id:"this指向-普通函数、箭头函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#this指向-普通函数、箭头函数"}},[t._v("#")]),t._v(" this指向（普通函数、箭头函数）？")]),t._v(" "),a("p",[t._v("普通函数指向调用处，箭头函数指向定义处")]),t._v(" "),a("h2",{attrs:{id:"css尺寸设置的单位"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#css尺寸设置的单位"}},[t._v("#")]),t._v(" CSS尺寸设置的单位?")]),t._v(" "),a("ol",[a("li",[t._v("px：绝对像素")]),t._v(" "),a("li",[t._v("rem：相对于根元素像素")]),t._v(" "),a("li",[t._v("em：相对于父元素像素")]),t._v(" "),a("li",[t._v("vw：视口宽度")]),t._v(" "),a("li",[t._v("vh：视口高度")])]),t._v(" "),a("h2",{attrs:{id:"说几个未知宽高元素水平垂直居中方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#说几个未知宽高元素水平垂直居中方法"}},[t._v("#")]),t._v(" 说几个未知宽高元素水平垂直居中方法")]),t._v(" "),a("ol",[a("li",[t._v("弹性布局{ display:flex; align-items:center;justify-content:center; }")]),t._v(" "),a("li",[t._v("定位{ position:absoolute; top,bottom,left,right:0 }")]),t._v(" "),a("li",[t._v("设置元素的父级为表格元素"),a("code",[t._v("display: table-cell")]),t._v("，其内部元素水平垂直都居中"),a("code",[t._v("text-align: center;vertical-align: middle;")]),t._v(" ，设置子元素为行内块"),a("code",[t._v("display: inline-block;")])]),t._v(" "),a("li",[t._v("自身平移自身高度50% transform: translate(-50%,-50%);")]),t._v(" "),a("li",[t._v("设置元素的父级为网格元素"),a("code",[t._v("display: grid")]),t._v("，设置父级和盒子内部子元素水平垂直都居中"),a("code",[t._v("justify-content:center; align-items:center")])])]),t._v(" "),a("h2",{attrs:{id:"说一说js变量提升"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#说一说js变量提升"}},[t._v("#")]),t._v(" 说一说JS变量提升？")]),t._v(" "),a("p",[t._v("函数和var声明的变量会有变量提升，js在预编译阶段会将函数和var声明的变量提升至最前面先执行，之后再按顺序执行代码块进行赋值，而let和const声明的变量只是创建提升，在预编译中将其创建，形成暂时性死区，不能提前访问和调用变量，只能在赋值之后进行调用和访问")]),t._v(" "),a("h2",{attrs:{id:"说一说-hashrouter-和-historyrouter的区别和原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#说一说-hashrouter-和-historyrouter的区别和原理"}},[t._v("#")]),t._v(" 说一说 HashRouter 和 HistoryRouter的区别和原理？")]),t._v(" "),a("ol",[a("li",[t._v("history和hash都是利用浏览器的2种特性实现前端路由，history是利用浏览历史记录栈的API实现，hash是监听location hash值变化事件来实现。")]),t._v(" "),a("li",[t._v("history的url没有#号，hash有#号。")]),t._v(" "),a("li",[t._v("相同的url,history会触发添加到浏览器历史记录栈中，hash不会触发，history需要后端配合，如果后端不配合刷新页面会出现404，hash不需要。")])]),t._v(" "),a("p",[t._v("hashRouter原理：通过window.onhashchange获取url中hash值。")]),t._v(" "),a("p",[t._v("historyRouter原理：通过history.pushState，使用它做页面跳转不会触发页面刷新，使用window.onpopstate监听浏览器的前进和后退。")]),t._v(" "),a("h2",{attrs:{id:"map-和-foreach-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#map-和-foreach-的区别"}},[t._v("#")]),t._v(" map 和 forEach 的区别？")]),t._v(" "),a("p",[t._v("map返回新数组，而forEach返回值为undefined。forEach能改变原数组，而map不会。")]),t._v(" "),a("h2",{attrs:{id:"说一说事件循环event-loop-宏任务与微任务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#说一说事件循环event-loop-宏任务与微任务"}},[t._v("#")]),t._v(" 说一说事件循环Event loop，宏任务与微任务？")]),t._v(" "),a("p",[t._v("js是单线程的，主线程在执行时会不断循环往复的从同步队列中读取任务，执行任务，当同步队列执行完毕后再从异步队列中依次执行。宏任务与微任务都属于异步任务，再执行上微任务的优先级高于宏任务，因此每一次都会先执行完微任务在执行宏任务。宏任务有定时器，Dom事件，ajax事件，requestAnimationFrame，微任务有：promise的回调、process.nextTick。")]),t._v(" "),a("h2",{attrs:{id:"vue3-0-实现数据双向绑定的方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue3-0-实现数据双向绑定的方法"}},[t._v("#")]),t._v(" Vue3.0 实现数据双向绑定的方法 ？")]),t._v(" "),a("p",[t._v("Proxy、数据拦截、劫持整个对象、返回一个新对象")]),t._v(" "),a("h2",{attrs:{id:"说一下diff算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#说一下diff算法"}},[t._v("#")]),t._v(" 说一下Diff算法？")]),t._v(" "),a("ol",[a("li",[t._v("出现：主流框架中多采用VNode更新结点，更新规则为diff算法。")]),t._v(" "),a("li",[t._v("原理：框架会将所有的结点先转化为虚拟节点Vnode，在发生更改后将VNode和原本页面的OldNode进行对比，然后以VNode为基准，在oldNode上进行准确的修改。（修改准则：原本没有新版有，则增加；原本有新版没有，则删除；都有则进行比较，都为文本结点则替换值；都为静态资源不处理；都为正常结点则替换）")])]),t._v(" "),a("h2",{attrs:{id:"说一说三栏布局的实现方案"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#说一说三栏布局的实现方案"}},[t._v("#")]),t._v(" 说一说三栏布局的实现方案")]),t._v(" "),a("ol",[a("li",[t._v("左右浮动 设置宽高 中间设置高 宽度自适应")]),t._v(" "),a("li",[t._v("bfc：左右浮动 中间overflow：hidden")]),t._v(" "),a("li",[t._v("flex布局 父元素设置flex 中间元素 设置flex-grow：1")])]),t._v(" "),a("h2",{attrs:{id:"说一下浏览器垃圾回收机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#说一下浏览器垃圾回收机制"}},[t._v("#")]),t._v(" 说一下浏览器垃圾回收机制？")]),t._v(" "),a("p",[t._v("1、标记清除：对所有活动对象进行标记，清除阶段会将没有标记的对象清除；标记整理算法：标记结束后，算法将活动对象压入内存一端，则需要清理的对象在边界，直接被清理掉就行。（效率低）\n2、引用计数：将对象是否不再需要简化定义为有没有其他对象引用它，如果没有引用指向这个对象，则会被垃圾回收机制回收。（内存空间不连续）")]),t._v(" "),a("h2",{attrs:{id:"说一说-vue-的-keep-alive"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#说一说-vue-的-keep-alive"}},[t._v("#")]),t._v(" 说一说 vue 的 keep-alive ？")]),t._v(" "),a("ol",[a("li",[t._v("keep-alive是vue的内置组件，能在组件切换过程中将状态保留在内存中，相当于缓存，防止DOM的重复渲染；")]),t._v(" "),a("li",[t._v("keep-alive有三个属性：include（只有名字匹配的才会被缓存）、exclude（任何名字匹配的都不会被缓存）、max（最多可以缓存多少个组件）。")]),t._v(" "),a("li",[t._v("在路由router的中：相应组件下规定meta属性，定义keep-alive：true；")]),t._v(" "),a("li",[t._v("可以结合Vue组件实例加载顺序讲解，VNode->实例化->_updata->真实Node，在实例化的时候会判断该组件是否被keep-alive保存过，是的话则直接拿其中的DOM进行渲染。")])]),t._v(" "),a("p",[t._v("被keep-alive缓存的组件比普通的组件对两个生命周期，一个是actived，在每次访问时会触发。deactived：在组件退出时触发。")]),t._v(" "),a("h2",{attrs:{id:"csrf攻击是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#csrf攻击是什么"}},[t._v("#")]),t._v(" CSRF攻击是什么？")]),t._v(" "),a("ol",[a("li",[t._v("概念：跨域请求伪造。")]),t._v(" "),a("li",[t._v("原理：诱导用户跳转到新的页面，利用 服务器的验证漏洞 和 用户之前的登入状态，来模拟用户进行操作。")]),t._v(" "),a("li",[t._v("防范：利用cookie的sameSize属性规定其他网站不能使用本网站的cookie。或者使用token验证，再去验证用户身份。")])]),t._v(" "),a("h2",{attrs:{id:"xss攻击是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#xss攻击是什么"}},[t._v("#")]),t._v(" XSS攻击是什么？")]),t._v(" "),a("p",[t._v("XSS是跨站脚本攻击。攻击者可以通过向Web页面里面插入script代码，当用户浏览这个页面时，就会运行被插入的script代码，达到攻击者的目的。 危害：泄露用户的登录信息cookie；恶意跳转：直接在页面中插入window.location.href进行跳转。")]),t._v(" "),a("h2",{attrs:{id:"说一说js继承的方法和优缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#说一说js继承的方法和优缺点"}},[t._v("#")]),t._v(" 说一说js继承的方法和优缺点？")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://www.cnblogs.com/wrhbk/p/14477637.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("link"),a("OutboundLink")],1)]),t._v(" "),a("h2",{attrs:{id:"说一说defer和async区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#说一说defer和async区别"}},[t._v("#")]),t._v(" 说一说defer和async区别？")]),t._v(" "),a("p",[t._v("html文件都是按顺序执行的，script标签中没有加defer和async时，浏览器在解析文档时遇到script标签就会停止解析阻塞文档解析，先加载JS文件，加载完之后立即执行，执行完毕后才能继续解析文档。 而在script标签中写入defer或者async时，就会使JS文件异步加载，即html执行到script标签时，JS加载和文档解析同时进行，而async是在JS加载完成后立即执行JS脚本，阻塞文档解析，而defer则是JS加载完成后，在文档解析完成后执行JS脚本")]),t._v(" "),a("h2",{attrs:{id:"说一下浏览器如何渲染页面的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#说一下浏览器如何渲染页面的"}},[t._v("#")]),t._v(" 说一下浏览器如何渲染页面的？")]),t._v(" "),a("ol",[a("li",[t._v("HTML被HTML解析器解析成DOM树。")]),t._v(" "),a("li",[t._v("CSS被CSS解析器解析成CSS规则树。")]),t._v(" "),a("li",[t._v("浏览器会将CSS规则树附着在DOM树上，并结合两者生成渲染树Render Tree。 4. 生成布局（flow），浏览器通过解析计算出每一个渲染树节点的位置和大小，在屏幕上画出渲染树的所有节点。")]),t._v(" "),a("li",[t._v("将布局绘制（paint）在屏幕上，显示出整个页面")])]),t._v(" "),a("h2",{attrs:{id:"computed和watch的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#computed和watch的区别"}},[t._v("#")]),t._v(" computed和watch的区别？")]),t._v(" "),a("ol",[a("li",[t._v("功能上：computed是计算属性，watch是监听一个值的变化，然后执行对应的回调。")]),t._v(" "),a("li",[t._v("是否调用缓存：computed中的函数所依赖的属性没有发生变化，那么调用当前的函数的时候会从缓存中读取，而watch在每次监听的值发生变化的时候都会执行回调。")]),t._v(" "),a("li",[t._v("是否调用return：computed中的函数必须要用return返回，watch中的函数不是必须要用return。")]),t._v(" "),a("li",[t._v("computed默认第一次加载的时候就开始监听；watch默认第一次加载不做监听，如果需要第一次加载做监听，添加immediate属性，设置为true（immediate:true）")]),t._v(" "),a("li",[t._v("使用场景：computed----当一个属性受多个属性影响的时候，使用computed-----购物车商品结算。watch–当一条数据影响多条数据的时候，使用watch-----搜索框.")])]),t._v(" "),a("h2",{attrs:{id:"vue-中-nexttick-作用与原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-中-nexttick-作用与原理"}},[t._v("#")]),t._v(" Vue 中 $nextTick 作用与原理？")]),t._v(" "),a("p",[t._v("vue中更新dom是异步操作，在修改完数据后，视图不会立刻更新，而是当同一事件循环中的所有数据变化完成之后，再进行统一的更新，所以有的时候在修改完数据后想要获取更新后的dom，则需要在nextTick中获取，nextTick的作用就是在当前渲染完成后执行，，解决了异步获取不到更新后dom问题，本质是反回promise")]),t._v(" "),a("h2",{attrs:{id:"new会发生什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#new会发生什么"}},[t._v("#")]),t._v(" new会发生什么？")]),t._v(" "),a("p",[t._v("在堆内存中开辟一个空间，其中this永远指向这个实例化出来的对象")]),t._v(" "),a("h2",{attrs:{id:"token-能放在cookie中吗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#token-能放在cookie中吗"}},[t._v("#")]),t._v(" token 能放在cookie中吗？")]),t._v(" "),a("p",[t._v("可以，")]),t._v(" "),a("ol",[a("li",[t._v("客户端使用用户名跟密码请求登录")]),t._v(" "),a("li",[t._v("服务端收到请求，去验证用户名与密码")]),t._v(" "),a("li",[t._v("验证成功后，服务端签发一个 token ，并把它发送给客户端")]),t._v(" "),a("li",[t._v("客户端接收 token 以后会把它存储起来，比如放在 cookie 里或者 localStorage 里")]),t._v(" "),a("li",[t._v("客户端每次发送请求时都需要带着服务端签发的 token（把 token 放到 HTTP 的 Header 里）")]),t._v(" "),a("li",[t._v("服务端收到请求后，需要验证请求里带有的 token ，如验证成功则返回对应的数据")])]),t._v(" "),a("h2",{attrs:{id:"浏览器输入url发生了什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器输入url发生了什么"}},[t._v("#")]),t._v(" 浏览器输入URL发生了什么？")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("解析URL")])]),t._v(" "),a("li",[a("p",[t._v("查找缓存")])]),t._v(" "),a("li",[a("p",[t._v("DNS解析")])]),t._v(" "),a("li",[a("p",[t._v("TCP握手")])]),t._v(" "),a("li",[a("p",[t._v("HTTP请求")])]),t._v(" "),a("li",[a("p",[t._v("TCP挥手")])]),t._v(" "),a("li",[a("p",[t._v("HTML渲染")])]),t._v(" "),a("li",[a("p",[t._v("url解析：判断是搜索内容还是请求URL")])]),t._v(" "),a("li",[a("p",[t._v("查找本地缓存：如果有缓存直接返回给页面，没有缓存则进入网络请求阶段")])]),t._v(" "),a("li",[a("p",[t._v("DNS解析")])]),t._v(" "),a("li",[a("p",[t._v("通过三次握手建立TCP连接")])]),t._v(" "),a("li",[a("p",[t._v("合成请求头信息，发送http请求")])]),t._v(" "),a("li",[a("p",[t._v("处理响应信息")])]),t._v(" "),a("li",[a("p",[t._v("通过四次挥手断开TCP连接")])]),t._v(" "),a("li",[a("p",[t._v("如果响应状态码301，则重定向")])]),t._v(" "),a("li",[a("p",[t._v("浏览器进行页面渲染：1）解析html，生成DOM树；2）根据css计算节点样式，生成stylesheet；3）生成布局树；4）为特定的元素生成独立图层；5）渲染页面")])])]),t._v(" "),a("h2",{attrs:{id:"组件通信的方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#组件通信的方式"}},[t._v("#")]),t._v(" 组件通信的方式？")]),t._v(" "),a("ol",[a("li",[t._v("父子：props，emit，refs")]),t._v(" "),a("li",[t._v("兄弟：eventbus，emit")]),t._v(" "),a("li",[t._v("隔代：inject，provide，attr，listener")]),t._v(" "),a("li",[t._v("不传火了：vuex，pinia")])]),t._v(" "),a("h2",{attrs:{id:"v-if-和-v-show区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#v-if-和-v-show区别"}},[t._v("#")]),t._v(" v-if 和 v-show区别？")]),t._v(" "),a("p",[t._v("v-show是操作display:none,而v-if是操作Dom直接进行删除和添加，在性能上不及v-show")]),t._v(" "),a("h2",{attrs:{id:"react生命周期的各个阶段是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react生命周期的各个阶段是什么"}},[t._v("#")]),t._v(" React生命周期的各个阶段是什么？")]),t._v(" "),a("p",[t._v("react生命周期分为3个阶段；分别是：1、创建阶段，也被称为初始化阶段，表示组件第一次在DOM树中进行渲染的过程；2、更新阶段，也叫存在阶段，表示组件被重新渲染的过程；3、卸载阶段，也叫销毁阶段，表示组件从DOM中删除的过程。")]),t._v(" "),a("h2",{attrs:{id:"react组件间传值的方法有哪些"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react组件间传值的方法有哪些"}},[t._v("#")]),t._v(" React组件间传值的方法有哪些？")]),t._v(" "),a("p",[t._v("父传子：使用属性props 子传父：使用方法调用 非相关组件之间传参：使用context上下文或者redux")]),t._v(" "),a("h2",{attrs:{id:"盒模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#盒模型"}},[t._v("#")]),t._v(" 盒模型？")]),t._v(" "),a("p",[t._v("css盒子的组成包括margin、border、padding、content； 盒子模型一共两种：标准盒模型（content-box）、怪异盒模型（border-box）； 标准盒模型在设置width和height时设置的是content的大小，盒子的大小还要加上padding、border； 怪异盒模型设置width和height时设置的是盒子的大小，会压缩content区域")]),t._v(" "),a("h2",{attrs:{id:"伪数组和数组的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#伪数组和数组的区别"}},[t._v("#")]),t._v(" 伪数组和数组的区别？")]),t._v(" "),a("ol",[a("li",[t._v("伪数组的特点：类型是object、不能使用数组方法、可以获取长度、可以使用for in遍历")]),t._v(" "),a("li",[t._v("伪数组可以装换为数组的方法：a. Array.prototype.slice.call() b.Array.from() c. [...伪数组]")]),t._v(" "),a("li",[t._v("有哪些是伪数组：函数的参数arguments，Map和Set的keys()、values()和entires()")])]),t._v(" "),a("h2",{attrs:{id:"如何实现可过期的localstorage数据"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何实现可过期的localstorage数据"}},[t._v("#")]),t._v(" 如何实现可过期的localstorage数据？")]),t._v(" "),a("p",[t._v("一种是惰性删除：惰性删除是指获取数据的时候，拿到存储的时间和当前时间做对比，如果超过过期时间就清除Cookie。 另一种是定时删除：每隔一段时间执行一次删除操作，并通过限制删除操作执行的次数和频率，来减少删除操作对CPU的长期占用。 LocalStorage清空应用场景：token存储在LocalStorage中，要清空")]),t._v(" "),a("h2",{attrs:{id:"axios的拦截器原理及应用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#axios的拦截器原理及应用"}},[t._v("#")]),t._v(" axios的拦截器原理及应用？")]),t._v(" "),a("p",[t._v("axios拦截器分为响应和请求拦截器，请求拦截器 在请求发送前进行必要操作处理，例如添加统一cookie、请求体加验证、设置请求头等，相当于是对每个接口里相同操作的一个封装； 响应拦截器 同理，响应拦截器也是如此功能，只是在请求得到响应之后，对响应体的一些处理，通常是数据统一处理等，也常来判断登录失效等。")]),t._v(" "),a("h2",{attrs:{id:"创建ajax过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#创建ajax过程"}},[t._v("#")]),t._v(" 创建ajax过程？")]),t._v(" "),a("ol",[a("li",[t._v("创建XML对象，new XMLHttpRequest（）；")]),t._v(" "),a("li",[t._v("设置请求参数，request.open（Method,服务器接口地址）；")]),t._v(" "),a("li",[t._v("发送请求，request.send（）如果是get请求不需要参数，post需要request.send（data）；监听成功后的状态变化，根据变化进行响应处理")])]),t._v(" "),a("h2",{attrs:{id:"有什么方法可以保持前后端实时通信"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#有什么方法可以保持前后端实时通信"}},[t._v("#")]),t._v(" 有什么方法可以保持前后端实时通信？")]),t._v(" "),a("p",[t._v("轮询、iframe、websocket、SSE")]),t._v(" "),a("p",[t._v("轮询适用于：小型应用，实时性不高 长轮询适用于：一些早期的对及时性有一些要求的应用：web IM 聊天 iframe适用于：客服通信等 WebSocket适用于：微信、网络互动游戏等 SSE适用于：金融股票数据、看板等")]),t._v(" "),a("h2",{attrs:{id:"重绘、重排区别如何避免"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#重绘、重排区别如何避免"}},[t._v("#")]),t._v(" 重绘、重排区别如何避免？")]),t._v(" "),a("p",[t._v("重排：当一个元素的位置、尺寸等发生改变的时候 浏览器需要重新计算该元素的几何属性并且摆放到正确的位置的过程就叫做重排。一般像页面初次渲染、带有动画的元素、添加/删除功能、图片放大缩小、浏览器窗口发生改变的时候都会触发重排。 重绘：当一个元素的外观、样式发生改变而布局不会改变，重新绘制的过程叫做重绘。 重排必定会触发重绘，而重绘则不一定会触发重排。一般来说，重排对性能的损耗更多一点")]),t._v(" "),a("p",[t._v("避免：使用translate替代top、使用visibility代替display:hidden、none、DOM离线后修改、使用class去修改样式、使用 absolute 或 fixed 脱离文档流 、使用GPU加速提升网站的动画渲染性能:transform、transform: translateZ(0); 或 transform: translate3d(0,0,0);不要选择table布局")]),t._v(" "),a("h2",{attrs:{id:"vue-列表为什么加-key"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-列表为什么加-key"}},[t._v("#")]),t._v(" Vue 列表为什么加 key？")]),t._v(" "),a("ol",[a("li",[t._v("key实际上是给vnode的唯一标识，也是diff的一种优化策略，可以根据key更快更准确的找到对应的vnode节点；")]),t._v(" "),a("li",[t._v("如果不用key就会使用就地复用原则，下一个元素使用上一个在当前位置元素的状态；")]),t._v(" "),a("li",[t._v("如果使用key，vue会更根据key的顺序记录element，曾经拥有了key的element如果不再出现的话，会被直接remove或者destoryed；")]),t._v(" "),a("li",[t._v("在v-for的数据list里面删除一个item，item之后的元素index会发生变化。")])]),t._v(" "),a("p",[t._v("便于进行diff，优化性能，key不能是index，不能重复")]),t._v(" "),a("h2",{attrs:{id:"vue-router-实现懒加载的方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-router-实现懒加载的方法"}},[t._v("#")]),t._v(" vue-router 实现懒加载的方法？")]),t._v(" "),a("p",[t._v("目前有三种方法：")]),t._v(" "),a("ol",[a("li",[t._v("利用Vue的异步组件和Webpack： const Home = require =>{ require(['../components/home.vue'],()=>{ resolve(require('../components/home.vue')); }) };")]),t._v(" "),a("li",[t._v("AMD在1的基础上 const Home = require =>{ require(['../components/home.vue'],resolved); };")]),t._v(" "),a("li",[t._v("ES6利用Webpack的chunk【推荐使用】 const Home = () =>import('../components/home.vue')")])]),t._v(" "),a("h2",{attrs:{id:"前端性能优化手段"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前端性能优化手段"}},[t._v("#")]),t._v(" 前端性能优化手段？")]),t._v(" "),a("p",[t._v("前端性能优化分为两类：一类是文件加载更快、另一类是文件渲染更快。")]),t._v(" "),a("p",[t._v("加载更快的方法：")]),t._v(" "),a("ol",[a("li",[t._v("让传输的数据包更小（压缩文件/图片）：图片压缩和文件压缩")]),t._v(" "),a("li",[t._v("减少网络请求的次数：雪碧图/精灵图、节流防抖")]),t._v(" "),a("li",[t._v("减少渲染的次数：缓存（HTTP缓存、本地缓存、Vue的keep-alive缓存等）")])]),t._v(" "),a("p",[t._v("渲染更快的方法：")]),t._v(" "),a("ol",[a("li",[t._v("提前渲染：ssr服务器端渲染")]),t._v(" "),a("li",[t._v("避免渲染阻塞：CSS放在HTML的head中 JS放在HTML的body底部")]),t._v(" "),a("li",[t._v("避免无用渲染：懒加载")]),t._v(" "),a("li",[t._v("减少渲染次数：对dom查询进行缓存、将dom操作合并、使用减少重排的标签")])]),t._v(" "),a("h2",{attrs:{id:"性能优化有哪些性能指标-如何量化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#性能优化有哪些性能指标-如何量化"}},[t._v("#")]),t._v(" 性能优化有哪些性能指标，如何量化？")]),t._v(" "),a("ol",[a("li",[t._v("性能评估 Chrome Performance选项卡 / Lighthouse 生成性能检测报告")]),t._v(" "),a("li",[t._v("值得关注的性能指标(1)LCP (Largest Contentful Paint 最大内容绘制 ) (2)首屏渲染时间（也叫白屏时间） （3）FCP (Fitst Contentful Paint 首先内容绘制 ) （4）可交互时间 (Time to Interactive TTI) (5) Network请求时间(jax,js等)")]),t._v(" "),a("li",[t._v("浏览器开发者工具什么都能看得到，可以调用性能监测API 或建立 前端监控系统(无痕埋点)")])]),t._v(" "),a("h2",{attrs:{id:"服务端渲染"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#服务端渲染"}},[t._v("#")]),t._v(" 服务端渲染？")]),t._v(" "),a("p",[t._v("SSR是指从服务端侧完成页面DOM结构和数据的拼接，然后再发送给浏览器，为其绑定事件和状态，能完成交互的过程。")]),t._v(" "),a("p",[t._v("优缺点：")]),t._v(" "),a("ol",[a("li",[t._v("减少前端耗时，解决首屏加载慢问题；")]),t._v(" "),a("li",[t._v("利于SEO；")]),t._v(" "),a("li",[t._v("无需占用客户端资源；")]),t._v(" "),a("li",[t._v("后端生成静态文件；")]),t._v(" "),a("li",[t._v("不利于前后端分离，开发效率不高；")]),t._v(" "),a("li",[t._v("占用服务器的资源。实现方式：传统的JSP、express+react、express+ejs、vue+nuxt。使用场景：一般不会用在公司项目内（涉及前后端分离开发问题），可以用户博客网站、官网、营销类网站等比较注重加载速度和渲染效率的时候。")])]),t._v(" "),a("h2",{attrs:{id:"对象扩展符用过吗-什么场景下"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对象扩展符用过吗-什么场景下"}},[t._v("#")]),t._v(" 对象扩展符用过吗(...)，什么场景下？")]),t._v(" "),a("p",[t._v("对象中的扩展运算符(...)用于取出参数对象中的所有可遍历的属性，浅拷贝到当前的对象中，浅拷贝和深拷贝：浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。")]),t._v(" "),a("h2",{attrs:{id:"vue钩子函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue钩子函数"}},[t._v("#")]),t._v(" vue钩子函数？")]),t._v(" "),a("ol",[a("li",[t._v("三个阶段\n"),a("ol",[a("li",[t._v("挂载阶段：beforeCreate、created、beforeMounted、mounted")]),t._v(" "),a("li",[t._v("更新阶段：beforeUpdate、updated")]),t._v(" "),a("li",[t._v("销毁阶段：beforeDestroy、destroyed")])])]),t._v(" "),a("li",[t._v("每个阶段的特性\n"),a("ol",[a("li",[t._v("beforeCreate：创建实例之前")]),t._v(" "),a("li",[t._v("created：实例创建完成（执行new Vue(options)），可访问data、computed、watch、methods上的方法和数据，可进行数据请求，未挂载到DOM结构上，不能获取el属性，如果要进行dom操作，那就要用nextTick函数")]),t._v(" "),a("li",[t._v("beforeMount：在挂载开始之前被调用，beforeMount之前，会找到对应的template，并编译成render函数")]),t._v(" "),a("li",[t._v("mounted：实例挂载到DOM上，此时可以通过DOM API获取到DOM节点，可进行数据请求")]),t._v(" "),a("li",[t._v("beforeupdate：响应式数据更新时调用，发生在虚拟DOM打补丁之前，适合在更新之前访问现有的DOM，比如手动移除已添加的事件监听器")]),t._v(" "),a("li",[t._v("updated：虚拟 DOM 重新渲染和打补丁之后调用，组件DOM已经更新")]),t._v(" "),a("li",[t._v("beforeDestroy：实例销毁之前调用，this仍能获取到实例，常用于销毁定时器、解绑全局事件、销毁插件对象等操作")]),t._v(" "),a("li",[t._v("destroyed: 实例销毁之后")])])]),t._v(" "),a("li",[t._v("父子组件执行顺序 挂载：父created -> 子created -> 子mounted> 父mounted 更新：父beforeUpdate -> 子beforeUpdated -> 子updated -> 父亲updated 销毁：父beforeDestroy -> 子beforeDestroy -> 子destroyed -> 父destroyed")])])])}),[],!1,null,null,null);e.default=s.exports}}]);